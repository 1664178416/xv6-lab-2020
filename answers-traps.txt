0000000000000000 <g>:
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int g(int x) {
   0:	1141                	addi	sp,sp,-16    # 栈顶指针下移16字节
   2:	e422                	sd	s0,8(sp)    # 存栈底指针s0/fp到sp+8的位置
   4:	0800                	addi	s0,sp,16    # 将sp+16即原sp的值作为新的栈帧
  return x+3;
}
   6:	250d                	addiw	a0,a0,3    # a0=a0+3, a0即为传入参数x又为返回值
   8:	6422                	ld	s0,8(sp)    # 从sp+8恢复原栈帧到s0
   a:	0141                	addi	sp,sp,16    # 回收栈顶指针
   c:	8082                	ret    # 返回

000000000000000e <f>:    # 与g()函数系统,相当于将g()内联了

int f(int x) {
   e:	1141                	addi	sp,sp,-16
  10:	e422                	sd	s0,8(sp)
  12:	0800                	addi	s0,sp,16
  return g(x);
}
  14:	250d                	addiw	a0,a0,3
  16:	6422                	ld	s0,8(sp)
  18:	0141                	addi	sp,sp,16
  1a:	8082                	ret

000000000000001c <main>:

void main(void) {
  1c:	1141                	addi	sp,sp,-16    # 栈顶指针下移16字节
  1e:	e406                	sd	ra,8(sp)    # 存返回地址到sp+8的位置
  20:	e022                	sd	s0,0(sp)    # 存栈底指针s0/fp到sp的位置
  22:	0800                	addi	s0,sp,16    # 更新栈帧s0
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13    # 加载13到a2寄存器
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0    # 将pc+0加载到a0
  2c:	7b050513          	addi	a0,a0,1968 # 7d8 <malloc+0xea>
  30:	00000097          	auipc	ra,0x0    # 将pc+0<<12加载到ra寄存器
  34:	600080e7          	jalr	1536(ra) # 630 <printf>    # 将pc设置为ra+1536,并将pc+4写入ra(即进行函数跳转)
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	auipc	ra,0x0
  3e:	27e080e7          	jalr	638(ra) # 2b8 <exit>

1.哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？

答：a0-a7，a2


2.main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联）

答：没有调用的代码，g(x)被内联到f(x)中，f(x)又被内联到main中


3.printf函数位于哪个地址？

答：jalr	1536(ra)，其中1536 = 0x600，ra为0x30，所以printf函数地址位于0x630



4.在main中printf的jalr之后的寄存器ra中有什么值？

答：jalr 指令的下一条汇编指令的地址。



5.运行以下代码。
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);

5.1 程序的输出是什么？这是将字节映射到字符的ASCII码表。

答：输出为"He110 World"，57616 = 0xE110，0x00646c72若是小端存储为72-6c-64-00，对应ASCLL码表为72:r， 6c:l， 64:d， 00:充当字符串结尾标识

5.2 输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？

i在内存中分布应该仍旧是72-6c-64-00，不过由于是大端存储，所以要改成0x726c6400,而57616不需要更改，因为是通过二进制数字读取的而非单个字符


6. 在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？
printf("x=%d y=%d", 3);

答；输出的是一个受调用前的代码影响的“随机”的值。因为 printf 尝试读的参数数量比提供的参数数量多。
第二个参数 `3` 通过 a1 传递，而第三个参数对应的寄存器 a2 在调用前不会被设置为任何具体的值，而是会
包含调用发生前的任何已经在里面的值。
即原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据